<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" type="text/css" href="../css/github.css">
        <title></title>
    </head>
    <body>
        <p><a href="/docs/html/index.html">index</a></p>
<hr>
<h1 id="example-information-retrieval">Example : Information Retrieval</h1>
<p>JSL borrows heavily from the reference implementation of a logic programming language described in <em>Structure and Interpretation of Computer Programs, MIT Press, Abelson, Sussman and Sussman</em> in <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4">section 4.4</a>.</p>
<p>The motivational example in the textbook describes a small personnel database along with some typical queries. The following exercises are given here with solutions, along with the <a href="#database">database</a> itself, translated from Scheme to JSL.</p>
<ul>
<li><a href="#exercise-455">exercise 4.55 a, b, c</a></li>
<li><a href="#exercise-456">exercise 4.56 a, b, c</a></li>
<li><a href="#exercise-457">exercise 4.57 a, b</a></li>
<li><a href="#exercise-458">exercise 4.58</a></li>
<li><a href="#exercise-459">exercise 4.59 a, b, c</a></li>
<li><a href="#exercise-460">exercise 4.60</a></li>
<li><a href="#exercise-461">exercise 4.61</a></li>
<li><a href="#exercise-462">exercise 4.62</a></li>
<li><a href="#exercise-463">exercise 4.63</a></li>
<li><a href="#exercise-464">exercise 4.64</a></li>
<li><a href="#exercise-465">exercise 4.65</a></li>
<li><a href="#exercise-466">exercise 4.66</a></li>
<li>exercise 4.67</li>
<li><a href="#exercise-468">exercise 4.68</a></li>
<li>exercise 4.69</li>
<li>exercise 4.70 thru 4.79</li>
</ul>
<h3 id="notes-">Notes :</h3>
<ol>
<li><p><strong>Omissions</strong> The omitted exercises : 4.67,4.70 thru 4.79  were focused on internals of the implementation, or posed deeper questions about implementation strategy. They will probably get picked up in subsequent iterations of JSL. Exercise 4.69 was omitted due to schedule constraints.</p>
</li>
<li><p><strong>Lists vs RegExp</strong> for processing strings : The scheme version regards job titles as lists, where the first element gives the department. Since JSL does not have this kind of list processing included, we have instead used strings for titles, with the first (whitespace delimited) token indicating the department. As such, extensive use of $call has  been made to define callbacks that use JS RegExp facilities for working with string valued department names (e.g. Exercise 4.55 b)</p>
</li>
<li><p><strong>Short circuit $or and $and</strong> : JSL implements shortcircuit evaluation of $or and $and. These operators stop at the first success or failure respectively. This makes the infinite loop in exercise 4.64 harder to reproduce. Explicit rearrangement of rules is required to force the recursive portion of the rule to be evaluated first.</p>
</li>
<li><p><strong>Callbacks</strong> : several intersting problems relating to duplicate suppression and accumulation (exercises 4.65, 4.66) were easily solved using callbacks in JS, with static variables in closures to hold state. This is natural for an embedded library.</p>
</li>
</ol>
<p><span id="the-database"></p>
<h2 id="the-database">The database</h2>
<p></span></p>
<p>The scheme database given in the book was translated into JSL (basically a set of JSON serializable JS objects).
Note that &quot;column names&quot; were invented for each relationship in the database to represent data in JS key/value objects
JSL deductions also use keys for unification between JS objects.</p>
<pre><code>
module.exports = [
//The personnel data base for Microshaft contains assertions about company personnel. 
// Here is the information about Ben Bitdiddle, the resident computer wizard:

[ { employee : { name : &#39;Bitdiddle Ben&#39;, address : [&#39;Slumerville&#39; , &#39;Ridge Road&#39;, 10] } } ],
[ { job :  { name : &#39;Bitdiddle Ben&#39; , title :  &#39;computer wizard&#39; } } ],
[ { salary : { name : &#39;Bitdiddle Ben&#39; , amount :  60000 } } ],

//As resident wizard, Ben is in charge of the company&#39;s computer division, and he supervises two programmers and one technician. 
// Here is the information about them:

[ { employee : { name : &#39;Hacker Alyssa P&#39;, address : [&#39;Cambridge&#39;, &#39;Mass Ave&#39;, 78] } } ],
[ { job : { name : &#39;Hacker Alyssa P&#39;, title :  &#39;computer programmer&#39; } } ],
[ { salary : { name : &#39;Hacker Alyssa P&#39;, amount : 40000 } } ],
[ { supervisor : { name : &#39;Hacker Alyssa P&#39; , manager :  &#39;Bitdiddle Ben&#39; } } ],
[ { employee : { name : &#39;Fect Cy D&#39; , address : [  &#39;Cambridge&#39;,  &#39;Ames Street&#39;, 3 ] } } ],
[ { job : { name : &#39;Fect Cy D&#39; , title :  &#39;computer programmer&#39; } } ],
[ { salary : { name : &#39;Fect Cy D&#39; , amount :  35000 } } ],
[ { supervisor : { name : &#39;Fect Cy D&#39; , manager :  &#39;Bitdiddle Ben&#39; } } ],
[ { employee : { name : &#39;Tweakit Lem E&#39; , address :  [&#39;Boston&#39;, &#39;Bay State Road&#39;, 22 ] } } ],
[ { job : { name : &#39;Tweakit Lem E&#39; , title :  &#39;computer technician&#39; } } ],
[ { salary : { name : &#39;Tweakit Lem E&#39; , amount : 25000 } } ],
[ { supervisor : { name : &#39;Tweakit Lem E&#39; , manager  :  &#39;Bitdiddle Ben&#39; } } ],

//There is also a programmer trainee, who is supervised by Alyssa:

[ { employee : { name : &#39;Reasoner Louis&#39; , address :  [&#39;Slumerville&#39;, &#39;Pine Tree Road&#39;, 80] } } ],
[ { job : { name : &#39;Reasoner Louis&#39; , title : &#39;computer programmer trainee&#39; } } ],
[ { salary : { name : &#39;Reasoner Louis&#39; , amount :  30000 } } ],
[ { supervisor : { name : &#39;Reasoner Louis&#39; , manager : &#39;Hacker Alyssa P&#39; } } ],

//All of these people are in the computer division, as indicated by the word computer as the first item in their job descriptions.

//Ben is a high-level employee. His supervisor is the company&#39;s big wheel himself:

[ { supervisor : { name : &#39;Bitdiddle Ben&#39; , manager :  &#39;Warbucks Oliver&#39; } } ],
[ { employee : { name : &#39;Warbucks Oliver&#39; , address :  [&#39;Swellesley&#39;, &#39;Top Heap Road&#39;] } } ],
[ { job : {  name : &#39;Warbucks Oliver&#39; , title :  &#39;administration big wheel&#39; } } ],
[ { salary : { name : &#39;Warbucks Oliver&#39; , amount : 150000 } } ],

//Besides the computer division supervised by Ben, the company has an accounting division, consisting of a chief accountant and his assistant:

[ { employee : { name : &#39;Scrooge Eben&#39; , address :  [&#39;Weston&#39;, &#39;Shady Lane&#39;, 10 ] } } ],
[ { job : { name : &#39;Scrooge Eben&#39; , title : &#39;accounting chief accountant&#39; } } ],
[ { salary : { name : &#39;Scrooge Eben&#39; , amount : 75000 } } ],
[ { supervisor : { name : &#39;Scrooge Eben&#39; , manager :  &#39;Warbucks Oliver&#39; } } ],
[ { employee : { name : &#39;Cratchet Robert&#39; , address : [&#39;Allston&#39;, &#39;N Harvard Street&#39;, 16] } } ],
[ { job : { name : &#39;Cratchet Robert&#39; , title : &#39;accounting scrivener&#39; } } ],
[ { salary : { name : &#39;Cratchet Robert&#39; , amount :  18000 } } ],
[ { supervisor : {name : &#39;Cratchet Robert&#39; , manager : &#39;Scrooge Eben&#39; } } ],

//There is also a secretary for the big wheel:

[ { employee : {name : &#39;Aull DeWitt&#39; , address : [&#39;Slumerville&#39;, &#39;Onion Square&#39;, 5] } } ],
[ { job : { name : &#39;Aull DeWitt&#39; , title :  &#39;administration secretary&#39; } }  ],
[ { salary : { name : &#39;Aull DeWitt&#39; , amount :  25000 } } ],
[ { supervisor : { name : &#39;Aull DeWitt&#39; , manager :  &#39;Warbucks Oliver&#39; } } ],

//The data base also contains assertions about which kinds of jobs can be done by people holding other kinds of jobs. 
// For instance, a computer wizard can do the jobs of both a computer programmer and a computer technician:

[ { can_do_job : { who : &#39;computer wizard&#39; , whose :  &#39;computer programmer&#39; } } ],
[ { can_do_job : { who : &#39;computer wizard&#39; , whose :  &#39;computer technician&#39; } } ],

//A computer programmer could fill in for a trainee:

[ { can_do_job : { who : &#39;computer programmer&#39; , whose : &#39;computer programmer trainee&#39; } } ],

//Also, as is well known,

[ { can_do_job : { who : &#39;administration secretary&#39; , whose : &#39;administration big wheel&#39; } } ]

]
</code></pre><p><span id="exercise-455"></p>
<h2 id="exercise-4-55">Exercise 4.55</h2>
<p></span></p>
<pre><code>
/*Exercise 4.55.  Give simple queries that retrieve the following information from the data base:

a. all people supervised by Ben Bitdiddle;*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require (&#39;./db.js&#39;);

var filterRule = [
                [   { result : [&#39;$x&#39;] },
                    { supervisor : { name : &#39;$x&#39;, manager : &#39;Bitdiddle Ben&#39; } }
                ] ];
var query = [ { result : &#39;$result&#39; } ]; 
var transform = &#39;$result&#39;;

function match (x,y) {
    return x.match(new RegExp(y));
}

var callbacks = {
    match : match
}
var jsl = new JSL({rules : ruleset.concat(filterRule), query: query, transform : transform, callbacks : callbacks});
var response = jsl.run();

module.exports = response;


/*
response  

[
    [
        &quot;Hacker Alyssa P&quot;
    ],
    [
        &quot;Fect Cy D&quot;
    ],
    [
        &quot;Tweakit Lem E&quot;
    ]
]

*/
</code></pre><pre><code>
/*Exercise 4.55.  Give simple queries that retrieve the following information from the data base:

b. the names and jobs of all people in the accounting division;*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require (&#39;./db.js&#39;);

var filterRule = [
                [   { result : [&#39;$x&#39;, &#39;$y&#39;] },
                    { job : { name : &#39;$x&#39;, title : &#39;$y&#39; } },
                    { $call : [ &#39;match&#39;, &#39;$y&#39;, &#39;^account&#39; ] } 
                ] ];
var query = [ { result : &#39;$result&#39; } ]; 
var transform = &#39;$result&#39;;

function match (x,y) {
    return x.match(new RegExp(y));
}

var callbacks = {
    match : match
}
var jsl = new JSL({rules : ruleset.concat(filterRule), query: query, transform : transform, callbacks : callbacks});
var response = jsl.run();

module.exports = response;


/*
response  

[
    [
        &quot;Scrooge Eben&quot;,
        &quot;accounting chief accountant&quot;
    ],
    [
        &quot;Cratchet Robert&quot;,
        &quot;accounting scrivener&quot;
    ]
]

*/
</code></pre><pre><code>
/*Exercise 4.55.  Give simple queries that retrieve the following information from the data base:

c. the names and addresses of all people who live in Slumerville.
*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require (&#39;./db.js&#39;);

var filterRule = [
                [   { result : [&#39;$x&#39;, [&#39;$y&#39;, &#39;$z&#39;, &#39;$w&#39;]] },
                    { employee : { name : &#39;$x&#39;, address : [&#39;$y&#39;, &#39;$z&#39;, &#39;$w&#39;] } }, //&lt;-- extract first element of address array into $y
                    { $call : [ &#39;match&#39;, &#39;$y&#39;, &#39;^Slumerville&#39;] } 
                ] ];
var query = [ { result : &#39;$result&#39; } ]; 
var transform = &#39;$result&#39;;

function match (x,y) {
    return x.match(new RegExp(y));
}

var callbacks = {
    match : match
}
var jsl = new JSL({rules : ruleset.concat(filterRule), query: query, transform : transform, callbacks : callbacks});
var response = jsl.run();

module.exports = response;


/*
response  


[
    [
        &quot;Bitdiddle Ben&quot;,
        [
            &quot;Slumerville&quot;,
            &quot;Ridge Road&quot;,
            10
        ]
    ],
    [
        &quot;Reasoner Louis&quot;,
        [
            &quot;Slumerville&quot;,
            &quot;Pine Tree Road&quot;,
            80
        ]
    ],
    [
        &quot;Aull DeWitt&quot;,
        [
            &quot;Slumerville&quot;,
            &quot;Onion Square&quot;,
            5
        ]
    ]
]

*/
</code></pre><p><span id="exercise-456"></p>
<h2 id="exercise-4-56">Exercise 4.56</h2>
<p></span></p>
<pre><code>
/*Exercise 4.56.  Formulate compound queries that retrieve the following information:

a. the names of all people who are supervised by Ben Bitdiddle, together with their addresses;

*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require (&#39;./db.js&#39;);

var filterRule = [
                [   { result : [&#39;$x&#39;, [&#39;$y&#39;, &#39;$z&#39;, &#39;$w&#39;]] },
                    { supervisor : { name : &#39;$x&#39;, manager: &#39;Bitdiddle Ben&#39; } },
                    { employee : { name : &#39;$x&#39;, address : [&#39;$y&#39;, &#39;$z&#39;, &#39;$w&#39;] } }
                ] ];
var query = [ { result : &#39;$result&#39; } ]; 
var transform = &#39;$result&#39;;


var jsl = new JSL({rules : ruleset.concat(filterRule), query: query, transform: transform});
var response = jsl.run();

module.exports = response;


/*
response  

[
    [
        &quot;Hacker Alyssa P&quot;,
        [
            &quot;Cambridge&quot;,
            &quot;Mass Ave&quot;,
            78
        ]
    ],
    [
        &quot;Fect Cy D&quot;,
        [
            &quot;Cambridge&quot;,
            &quot;Ames Street&quot;,
            3
        ]
    ],
    [
        &quot;Tweakit Lem E&quot;,
        [
            &quot;Boston&quot;,
            &quot;Bay State Road&quot;,
            22
        ]
    ]
]

*/
</code></pre><pre><code>
/*Exercise 4.56.  Formulate compound queries that retrieve the following information:

b. all people whose salary is less than Ben Bitdiddle&#39;s, together with their salary and Ben Bitdiddle&#39;s salary;
*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require (&#39;./db.js&#39;);

var filterRules = [
               [   { benSalary : &#39;$benSalary&#39;},
                   { salary : { name : &#39;Bitdiddle Ben&#39;, amount : &#39;$benSalary&#39;} }
               ], 
               [   { result : { name : &#39;$x&#39;, salary : &#39;$y&#39;, benSalary : &#39;$z&#39;} },
                    { benSalary : &#39;$z&#39;},
                    { salary : { name : &#39;$x&#39;, amount : &#39;$y&#39; } }, 
                    { $call : [ &#39;lt&#39;, &#39;$y&#39;, &#39;$z&#39;] } 
                ] ];
var query = [ { result : &#39;$result&#39; } ]; 
var transform = &#39;$result&#39;;

function lt (x,y) {
    return x &lt; y ? true : null
}

var callbacks = {
    lt : lt
}
var jsl = new JSL({rules : ruleset.concat(filterRules), query: query, transform: transform, callbacks : callbacks});
var response = jsl.run();

module.exports = response;


/*
response  

[
    {
        &quot;name&quot;: &quot;Hacker Alyssa P&quot;,
        &quot;salary&quot;: 40000,
        &quot;benSalary&quot;: 60000
    },
    {
        &quot;name&quot;: &quot;Fect Cy D&quot;,
        &quot;salary&quot;: 35000,
        &quot;benSalary&quot;: 60000
    },
    {
        &quot;name&quot;: &quot;Tweakit Lem E&quot;,
        &quot;salary&quot;: 25000,
        &quot;benSalary&quot;: 60000
    },
    {
        &quot;name&quot;: &quot;Reasoner Louis&quot;,
        &quot;salary&quot;: 30000,
        &quot;benSalary&quot;: 60000
    },
    {
        &quot;name&quot;: &quot;Cratchet Robert&quot;,
        &quot;salary&quot;: 18000,
        &quot;benSalary&quot;: 60000
    },
    {
        &quot;name&quot;: &quot;Aull DeWitt&quot;,
        &quot;salary&quot;: 25000,
        &quot;benSalary&quot;: 60000
    }
]

*/
</code></pre><pre><code>
/*Exercise 4.56.  Formulate compound queries that retrieve the following information:

c. all people who are supervised by someone who is not in the computer division, together with the supervisor&#39;s name and job.
*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require (&#39;./db.js&#39;);

var filterRules = [
               [    { result : { name : &#39;$x&#39;, supervisor : &#39;$y&#39;, supervisorTitle : &#39;$z&#39;} },
                    { supervisor : { name : &#39;$x&#39;, manager : &#39;$y&#39;} },
                    { job : { name : &#39;$y&#39;, title : &#39;$z&#39;} },
                    { $call : [ &#39;nomatch&#39;, &#39;$z&#39;, &#39;^computer&#39;] } 
                ] ];
var query = [ { result : &#39;$result&#39; } ]; 
var transform = &#39;$result&#39;;

function nomatch (x,y) {
    return x.match(new RegExp(y)) != null ? null : true; 
}

var callbacks = {
    nomatch : nomatch
}
var jsl = new JSL({rules : ruleset.concat(filterRules), query: query, transform: transform, callbacks : callbacks});
var response = jsl.run();

module.exports = response;


/*
response  

[
    {
        &quot;name&quot;: &quot;Bitdiddle Ben&quot;,
        &quot;supervisor&quot;: &quot;Warbucks Oliver&quot;,
        &quot;supervisorTitle&quot;: &quot;administration big wheel&quot;
    },
    {
        &quot;name&quot;: &quot;Scrooge Eben&quot;,
        &quot;supervisor&quot;: &quot;Warbucks Oliver&quot;,
        &quot;supervisorTitle&quot;: &quot;administration big wheel&quot;
    },
    {
        &quot;name&quot;: &quot;Cratchet Robert&quot;,
        &quot;supervisor&quot;: &quot;Scrooge Eben&quot;,
        &quot;supervisorTitle&quot;: &quot;accounting chief accountant&quot;
    },
    {
        &quot;name&quot;: &quot;Aull DeWitt&quot;,
        &quot;supervisor&quot;: &quot;Warbucks Oliver&quot;,
        &quot;supervisorTitle&quot;: &quot;administration big wheel&quot;
    }
]

*/
</code></pre><p><span id="exercise-457"></p>
<h2 id="exercise-4-57">Exercise 4.57</h2>
<p></span></p>
<pre><code>
/*Exercise 4.57.  Define a rule that says that person 1 can replace person 2 
    if either person 1 does the same job as person 2 
        or someone who does person 1&#39;s job can also do person 2&#39;s job, 
        and if person 1 and person 2 are not the same person. 

        Using your rule, give queries that find the following:

        a.  all people who can replace Cy D. Fect;
*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require (&#39;./db.js&#39;);

var filterRules = [
                    [
                        { replace : { name : &#39;$x&#39;, replacement : &#39;$y&#39;} },
                        { employee : { name : &#39;$x&#39; } },
                        { employee : { name : &#39;$y&#39; } },
                        { $not : [ {$bind : [ &#39;$x&#39;, &#39;$y&#39;] } ] },
                        { $or : [ 
                            { $and : [ 
                                { job : { name : &#39;$x&#39;, title : &#39;$t&#39;} },
                                { job : { name : &#39;$y&#39;, title : &#39;$t&#39;} },
                            ]},
                            { $and : [
                                { job : { name : &#39;$x&#39;, title : &#39;$tx&#39; } },
                                { job : { name : &#39;$y&#39;, title : &#39;$ty&#39; } },
                                { can_do_job : { who : &#39;$ty&#39;, whose : &#39;$tx&#39; } }
                            ]}
                        ]}
                    ],
                ];
var query = [ { replace : &#39;$replace&#39; } ]; 
var transform = &#39;$replace&#39;;


var jsl = new JSL({rules : ruleset.concat(filterRules), query: query, transform: transform});
var response = jsl.run();

module.exports = response;


/*
response  

[
    {
        &quot;name&quot;: &quot;Hacker Alyssa P&quot;,
        &quot;replacement&quot;: &quot;Bitdiddle Ben&quot;
    },
    {
        &quot;name&quot;: &quot;Hacker Alyssa P&quot;,
        &quot;replacement&quot;: &quot;Fect Cy D&quot;
    },
    {
        &quot;name&quot;: &quot;Fect Cy D&quot;,
        &quot;replacement&quot;: &quot;Bitdiddle Ben&quot;
    },
    {
        &quot;name&quot;: &quot;Fect Cy D&quot;,
        &quot;replacement&quot;: &quot;Hacker Alyssa P&quot;
    },
    {
        &quot;name&quot;: &quot;Tweakit Lem E&quot;,
        &quot;replacement&quot;: &quot;Bitdiddle Ben&quot;
    },
    {
        &quot;name&quot;: &quot;Reasoner Louis&quot;,
        &quot;replacement&quot;: &quot;Hacker Alyssa P&quot;
    },
    {
        &quot;name&quot;: &quot;Reasoner Louis&quot;,
        &quot;replacement&quot;: &quot;Fect Cy D&quot;
    },
    {
        &quot;name&quot;: &quot;Warbucks Oliver&quot;,
        &quot;replacement&quot;: &quot;Aull DeWitt&quot;
    }
]

*/
</code></pre><pre><code>
/*Exercise 4.57.  Define a rule that says that person 1 can replace person 2 
    if either person 1 does the same job as person 2 
        or someone who does person 1&#39;s job can also do person 2&#39;s job, 
        and if person 1 and person 2 are not the same person. 

        Using your rule, give queries that find the following:

b.  all people who can replace someone who is being paid more than they are, together with the two salaries.

*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require (&#39;./db.js&#39;);

var filterRules = [
                    [
                        { replace : { name : &#39;$x&#39;, replacement : &#39;$y&#39;} },
                        { employee : { name : &#39;$x&#39; } },
                        { employee : { name : &#39;$y&#39; } },
                        { $not : [ {$bind : [ &#39;$x&#39;, &#39;$y&#39;] } ] },
                        { $or : [ 
                            { $and : [ 
                                { job : { name : &#39;$x&#39;, title : &#39;$t&#39;} },
                                { job : { name : &#39;$y&#39;, title : &#39;$t&#39;} },
                            ]},
                            { $and : [
                                { job : { name : &#39;$x&#39;, title : &#39;$tx&#39; } },
                                { job : { name : &#39;$y&#39;, title : &#39;$ty&#39; } },
                                { can_do_job : { who : &#39;$ty&#39;, whose : &#39;$tx&#39; } }
                            ]}
                        ]}
                    ],
                    [ 
                        { result : { name : &#39;$x&#39;, replacement : &#39;$y&#39;, salary : &#39;$sx&#39;, replSalary : &#39;$sy&#39; } },
                        { replace : { name : &#39;$x&#39;, replacement : &#39;$y&#39; } },
                        { salary : { name : &#39;$x&#39;, amount : &#39;$sx&#39; } },
                        { salary : { name : &#39;$y&#39;, amount : &#39;$sy&#39; } },
                        { $call : [ &#39;gt&#39;, &#39;$sx&#39;, &#39;$sy&#39;] }
                    ]
                ];
var query = [ { result : &#39;$result&#39; } ]; 
var transform = &#39;$result&#39;;

function gt (x,y) {
    return x &gt; y ? true : null;
}

var callbacks = { gt : gt };
var jsl = new JSL({rules : ruleset.concat(filterRules), query: query, transform: transform, callbacks : callbacks});
var response = jsl.run();

module.exports = response;


/*
response  

[
    {
        &quot;name&quot;: &quot;Hacker Alyssa P&quot;,
        &quot;replacement&quot;: &quot;Fect Cy D&quot;,
        &quot;salary&quot;: 40000,
        &quot;replSalary&quot;: 35000
    },
    {
        &quot;name&quot;: &quot;Warbucks Oliver&quot;,
        &quot;replacement&quot;: &quot;Aull DeWitt&quot;,
        &quot;salary&quot;: 150000,
        &quot;replSalary&quot;: 25000
    }
]

*/
</code></pre><p><span id="exercise-458"></p>
<h2 id="exercise-4-58">Exercise 4.58</h2>
<p></span></p>
<pre><code>/*
Exercise 4.58.  Define a rule that says that a person is a ``big shot&#39;&#39; in a division 
if the person works in the division but does not have a supervisor who works in the division.
*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require (&#39;./db.js&#39;);

var filterRules = [
                    [
                        { bigShot : { name : &#39;$x&#39;, title : &#39;$tx&#39;, supervisor : &#39;$y&#39;, supervisorTitle : &#39;$ty&#39; } },
                        { employee : { name : &#39;$x&#39;} },
                        { supervisor : { name : &#39;$x&#39;, manager : &#39;$y&#39;} },
                        { job : { name : &#39;$x&#39;, title : &#39;$tx&#39; } },
                        { job : { name : &#39;$y&#39;, title : &#39;$ty&#39; } },
                        { $call : [ &#39;noMatchFirst&#39;, &#39;$tx&#39;, &#39;$ty&#39;] }
                    ],
                ];
var query = [ { bigShot : { name : &#39;$name&#39;, title : &#39;$title&#39; , supervisor : &#39;$y&#39;, supervisorTitle : &#39;$ty&#39; } } ]; 
var transform = { name : &#39;$name&#39;, title : &#39;$title&#39; , supervisor : &#39;$y&#39;, supervisorTitle : &#39;$ty&#39; }; 

function noMatchFirst (x,y) {
    var x1 = (x.split(/\s+/)).shift();
    var y1 = (y.split(/\s+/)).shift();
    return x1 !== y1 ? true : null;
}

var callbacks = { noMatchFirst : noMatchFirst };
var jsl = new JSL({rules : ruleset.concat(filterRules), query: query, transform: transform, callbacks : callbacks});
var response = jsl.run();

module.exports = response;


/*
response  

[
    {
        &quot;name&quot;: &quot;Bitdiddle Ben&quot;,
        &quot;title&quot;: &quot;computer wizard&quot;,
        &quot;supervisor&quot;: &quot;Warbucks Oliver&quot;,
        &quot;supervisorTitle&quot;: &quot;administration big wheel&quot;
    },
    {
        &quot;name&quot;: &quot;Scrooge Eben&quot;,
        &quot;title&quot;: &quot;accounting chief accountant&quot;,
        &quot;supervisor&quot;: &quot;Warbucks Oliver&quot;,
        &quot;supervisorTitle&quot;: &quot;administration big wheel&quot;
    }
]

*/
</code></pre><p><span id="exercise-459"></p>
<h2 id="exercise-4-59">Exercise 4.59</h2>
<p></span></p>
<pre><code>/*
Exercise 4.59.  Ben Bitdiddle has missed one meeting too many. Fearing that his habit of forgetting meetings could cost him his job, Ben decides to do something about it. He adds all the weekly meetings of the firm to the Microshaft data base by asserting the following:

(meeting accounting (Monday 9am))
(meeting administration (Monday 10am))
(meeting computer (Wednesday 3pm))
(meeting administration (Friday 1pm))

Each of the above assertions is for a meeting of an entire division. Ben also adds an entry for the company-wide meeting that spans all the divisions. All of the company&#39;s employees attend this meeting.

(meeting whole-company (Wednesday 4pm))

a. On Friday morning, Ben wants to query the data base for all the meetings that occur that day. What query should he use?
*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require (&#39;./db.js&#39;);

var meetings = [
    [{meeting : { department : &#39;accounting&#39;, day : &#39;Monday&#39;, hour : 9, minute : 0} }],
    [{meeting : { department : &#39;administration&#39;, day : &#39;Monday&#39;, hour : 10, minute : 0} }],
    [{meeting : { department : &#39;computer&#39;, day : &#39;Wednesday&#39;, hour : 15, minute : 0} }],
    [{meeting : { department : &#39;administration&#39;, day : &#39;Friday&#39;, hour : 13, minute : 0} }],
    [{meeting : { department : &#39;whole-company&#39;, day : &#39;Wednesday&#39;, hour : 13, minute : 0} }],
];

var query = [ { meeting : { department : &#39;$d&#39;, day : &#39;Friday&#39;, hour : &#39;$h&#39;, minute : &#39;$m&#39;} } ]; 
var transform = { department : &#39;$d&#39;, day : &#39;Friday&#39;, hour : &#39;$h&#39;, minute : &#39;$m&#39;}; 

var jsl = new JSL({rules : ruleset.concat(meetings), query: query, transform: transform});
var response = jsl.run();

module.exports = response;


/*
response  

[
    {
        &quot;department&quot;: &quot;administration&quot;,
        &quot;day&quot;: &quot;Friday&quot;,
        &quot;hour&quot;: 13,
        &quot;minute&quot;: 0
    }
]

*/
</code></pre><pre><code>/*

b. Alyssa P. Hacker is unimpressed. She thinks it would be much more useful to be able to ask for her meetings by specifying her name. So she designs a rule that says that a person&#39;s meetings include all whole-company meetings plus all meetings of that person&#39;s division. Fill in the body of Alyssa&#39;s rule.

(rule (meeting-time ?person ?day-and-time)
      &lt;rule-body&gt;)
*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require (&#39;./db.js&#39;);

var meetings = [
    [{meeting : { department : &#39;accounting&#39;, day : &#39;Monday&#39;, hour : 9, minute : 0} }],
    [{meeting : { department : &#39;administration&#39;, day : &#39;Monday&#39;, hour : 10, minute : 0} }],
    [{meeting : { department : &#39;computer&#39;, day : &#39;Wednesday&#39;, hour : 15, minute : 0} }],
    [{meeting : { department : &#39;administration&#39;, day : &#39;Friday&#39;, hour : 13, minute : 0} }],
    [{meeting : { department : &#39;whole-company&#39;, day : &#39;Wednesday&#39;, hour : 13, minute : 0} }],
];

var filterRules = [
    [
        { meeting_time : { person : &#39;$person&#39;, dept : &#39;$dept&#39;, day : &#39;$day&#39;, hour : &#39;$hour&#39;, minute : &#39;$minute&#39; } },
        { job : { name : &#39;$person&#39;, title : &#39;$title&#39;} },
        { meeting : { department : &#39;$dept&#39;, day : &#39;$day&#39;, hour : &#39;$hour&#39;, minute : &#39;$minute&#39; } },
        { $or : [
            { $call : [ &#39;deptMatch&#39;, &#39;$title&#39;, &#39;$dept&#39;] },
            {$bind : [ &#39;$dept&#39;, &#39;whole-company&#39;] }
        ]}
    ]
];

function deptMatch (title, dept) {
    var re = new RegExp(&#39;^&#39; + dept + &#39;\\s+&#39;);
    return title.match(re); // match returns null on failure, which is what we need callbacks to return on failure
}

var callbacks = { 
    deptMatch : deptMatch
};
// sample query to get Alyssa P Hacker&#39;s meetings for the whole week

var query = [ { meeting_time : { person : &#39;Hacker Alyssa P&#39;, dept : &#39;$dept&#39;, day : &#39;$day&#39;, hour : &#39;$hour&#39;, minute : &#39;$min&#39;} } ]; 
var transform = { person : &#39;Hacker Alyssa P&#39;, dept : &#39;$dept&#39;, day : &#39;$day&#39;, hour : &#39;$hour&#39;, minute : &#39;$min&#39;};

var jsl = new JSL({rules : ruleset.concat(meetings, filterRules), query: query, transform: transform, callbacks : callbacks});
var response = jsl.run();

module.exports = response;


/*
response  

[
    {
        &quot;person&quot;: &quot;Hacker Alyssa P&quot;,
        &quot;dept&quot;: &quot;computer&quot;,
        &quot;day&quot;: &quot;Wednesday&quot;,
        &quot;hour&quot;: 15,
        &quot;minute&quot;: 0
    },
    {
        &quot;person&quot;: &quot;Hacker Alyssa P&quot;,
        &quot;dept&quot;: &quot;whole-company&quot;,
        &quot;day&quot;: &quot;Wednesday&quot;,
        &quot;hour&quot;: 13,
        &quot;minute&quot;: 0
    }
]

*/
</code></pre><pre><code>/*
c. Alyssa arrives at work on Wednesday morning and wonders what meetings she has to attend that day. 
Having defined the above rule, what query should she make to find this out?


*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require (&#39;./db.js&#39;);

var meetings = [
    [{meeting : { department : &#39;accounting&#39;, day : &#39;Monday&#39;, hour : 9, minute : 0} }],
    [{meeting : { department : &#39;administration&#39;, day : &#39;Monday&#39;, hour : 10, minute : 0} }],
    [{meeting : { department : &#39;computer&#39;, day : &#39;Wednesday&#39;, hour : 15, minute : 0} }],
    [{meeting : { department : &#39;administration&#39;, day : &#39;Friday&#39;, hour : 13, minute : 0} }],
    [{meeting : { department : &#39;whole-company&#39;, day : &#39;Wednesday&#39;, hour : 13, minute : 0} }],
];

var filterRules = [
    [
        { meeting_time : { person : &#39;$person&#39;, dept : &#39;$dept&#39;, day : &#39;$day&#39;, hour : &#39;$hour&#39;, minute : &#39;$minute&#39; } },
        { job : { name : &#39;$person&#39;, title : &#39;$title&#39;} },
        { meeting : { department : &#39;$dept&#39;, day : &#39;$day&#39;, hour : &#39;$hour&#39;, minute : &#39;$minute&#39; } },
        { $or : [
            { $call : [ &#39;deptMatch&#39;, &#39;$title&#39;, &#39;$dept&#39;] },
            {$bind : [ &#39;$dept&#39;, &#39;whole-company&#39;] }
        ]}
    ]
];

function deptMatch (title, dept) {
    var re = new RegExp(&#39;^&#39; + dept + &#39;\\s+&#39;);
    return title.match(re); // match returns null on failure, which is what we need callbacks to return on failure
}

var callbacks = { 
    deptMatch : deptMatch
};
// sample query to get Alyssa P Hacker&#39;s meetings for the whole week

var query = [ { meeting_time : { person : &#39;Hacker Alyssa P&#39;, dept : &#39;$dept&#39;, day : &#39;Wednesday&#39;, hour : &#39;$hour&#39;, minute : &#39;$min&#39;} } ]; 
var transform = { person : &#39;Hacker Alyssa P&#39;, dept : &#39;$dept&#39;, day : &#39;Wednesday&#39;, hour : &#39;$hour&#39;, minute : &#39;$min&#39;};

var jsl = new JSL({rules : ruleset.concat(meetings, filterRules), query: query, transform: transform, callbacks : callbacks});
var response = jsl.run();

module.exports = response;


/*
response  

[
    {
        &quot;person&quot;: &quot;Hacker Alyssa P&quot;,
        &quot;dept&quot;: &quot;computer&quot;,
        &quot;day&quot;: &quot;Wednesday&quot;,
        &quot;hour&quot;: 15,
        &quot;minute&quot;: 0
    },
    {
        &quot;person&quot;: &quot;Hacker Alyssa P&quot;,
        &quot;dept&quot;: &quot;whole-company&quot;,
        &quot;day&quot;: &quot;Wednesday&quot;,
        &quot;hour&quot;: 13,
        &quot;minute&quot;: 0
    }
]

*/
</code></pre><p><span id="exercise-460"></p>
<h2 id="exercise-4-60">Exercise 4.60</h2>
<p></span></p>
<pre><code>/*
...
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
...
...
Exercise 4.60.  By giving the query

(lives-near ?person (Hacker Alyssa P))

Alyssa P. Hacker is able to find people who live near her, with whom she can ride to work. 
On the other hand, when she tries to find all pairs of people who live near each other by querying

(lives-near ?person-1 ?person-2)

she notices that each pair of people who live near each other is listed twice; for example,

(lives-near (Hacker Alyssa P) (Fect Cy D))
(lives-near (Fect Cy D) (Hacker Alyssa P))

Why does this happen? Is there a way to find a list of people who live near each other, in which each pair appears only once? Explain.

*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require (&#39;./db.js&#39;);

var problemRules = [
    [
        { lives_near : { person1 : &#39;$person1&#39;, person2: &#39;$person2&#39; } },
        { $and : [ 
            { employee : { name : &#39;$person1&#39;, address : [&#39;$town&#39;, &#39;$street1&#39;, &#39;$number1&#39;]} },
            { employee : { name : &#39;$person2&#39;, address : [&#39;$town&#39;, &#39;$street2&#39;, &#39;$number2&#39;]} },
            { $not : [ {$bind : [ &#39;$person1&#39;, &#39;$person2&#39;]  } ]  }            
        ]}
    ]
];

var query;
var response = {};
query = [ { lives_near : { person1 : &#39;$person1&#39;, person2: &#39;$person2&#39; } } ];


var pjsl = new JSL({rules : ruleset.concat(problemRules), query: query});
response.problem = pjsl.run();

/*
    We solve the duplicate suppression problem easily using a callback
*/
var solutionRules = [
    [
        { lives_near : { person1 : &#39;$person1&#39;, person2: &#39;$person2&#39; } },
        { $and : [ 
            { employee : { name : &#39;$person1&#39;, address : [&#39;$town&#39;, &#39;$street1&#39;, &#39;$number1&#39;]} },
            { employee : { name : &#39;$person2&#39;, address : [&#39;$town&#39;, &#39;$street2&#39;, &#39;$number2&#39;]} },
            { $not : [ {$bind : [ &#39;$person1&#39;, &#39;$person2&#39;]  } ]  },
            { $call : [ &#39;str_gt&#39;, &#39;$person1&#39;, &#39;$person2&#39;] }
        ]}
    ]
];

function str_gt (x,y) {
    return x &gt; y ? true : null;
}

var callbacks = { 
    str_gt : str_gt
};


var sjsl = new JSL({rules : ruleset.concat(solutionRules), query: query, callbacks : callbacks});
response.solution = sjsl.run();
module.exports = response;


/*
response  

{
    &quot;problem&quot;: [
        [
            {
                &quot;lives_near&quot;: {
                    &quot;person1&quot;: &quot;Bitdiddle Ben&quot;,
                    &quot;person2&quot;: &quot;Reasoner Louis&quot;
                }
            }
        ],
        [
            {
                &quot;lives_near&quot;: {
                    &quot;person1&quot;: &quot;Bitdiddle Ben&quot;,
                    &quot;person2&quot;: &quot;Aull DeWitt&quot;
                }
            }
        ],
        [
            {
                &quot;lives_near&quot;: {
                    &quot;person1&quot;: &quot;Hacker Alyssa P&quot;,
                    &quot;person2&quot;: &quot;Fect Cy D&quot;
                }
            }
        ],
        [
            {
                &quot;lives_near&quot;: {
                    &quot;person1&quot;: &quot;Fect Cy D&quot;,
                    &quot;person2&quot;: &quot;Hacker Alyssa P&quot;
                }
            }
        ],
        [
            {
                &quot;lives_near&quot;: {
                    &quot;person1&quot;: &quot;Reasoner Louis&quot;,
                    &quot;person2&quot;: &quot;Bitdiddle Ben&quot;
                }
            }
        ],
        [
            {
                &quot;lives_near&quot;: {
                    &quot;person1&quot;: &quot;Reasoner Louis&quot;,
                    &quot;person2&quot;: &quot;Aull DeWitt&quot;
                }
            }
        ],
        [
            {
                &quot;lives_near&quot;: {
                    &quot;person1&quot;: &quot;Aull DeWitt&quot;,
                    &quot;person2&quot;: &quot;Bitdiddle Ben&quot;
                }
            }
        ],
        [
            {
                &quot;lives_near&quot;: {
                    &quot;person1&quot;: &quot;Aull DeWitt&quot;,
                    &quot;person2&quot;: &quot;Reasoner Louis&quot;
                }
            }
        ]
    ],
    &quot;solution&quot;: [
        [
            {
                &quot;lives_near&quot;: {
                    &quot;person1&quot;: &quot;Bitdiddle Ben&quot;,
                    &quot;person2&quot;: &quot;Aull DeWitt&quot;
                }
            }
        ],
        [
            {
                &quot;lives_near&quot;: {
                    &quot;person1&quot;: &quot;Hacker Alyssa P&quot;,
                    &quot;person2&quot;: &quot;Fect Cy D&quot;
                }
            }
        ],
        [
            {
                &quot;lives_near&quot;: {
                    &quot;person1&quot;: &quot;Reasoner Louis&quot;,
                    &quot;person2&quot;: &quot;Bitdiddle Ben&quot;
                }
            }
        ],
        [
            {
                &quot;lives_near&quot;: {
                    &quot;person1&quot;: &quot;Reasoner Louis&quot;,
                    &quot;person2&quot;: &quot;Aull DeWitt&quot;
                }
            }
        ]
    ]
}

*/
</code></pre><p><span id="exercise-461"></p>
<h2 id="exercise-4-61">Exercise 4.61</h2>
<p></span></p>
<pre><code>/*
Exercise 4.61.  The following rules implement a next-to relation that finds adjacent elements of a list:

(rule (?x next-to ?y in (?x ?y . ?u)))

(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))

What will the response be to the following queries?

(?x next-to ?y in (1 (2 3) 4))

(?x next-to 1 in (2 1 3 1))

*/

var JSL = require(&#39;../../..&#39;);

var ruleset = [];

/* 
    We use the standard parseList callback included with JSL, 
    it returns the head and tail of an array
    parseList is the building block of cons/cdr style recursive list processing in JSL    
*/

var rules = [
    [
        { next_to : [&#39;$x&#39;, &#39;$y&#39;, &#39;$list&#39;] },
        { &#39;$and&#39; : [ 
            { $call : [ &#39;parseList&#39;, &#39;$list&#39;, [&#39;$x&#39;, &#39;$xtail&#39;] ] },
            { $call : [ &#39;parseList&#39;, &#39;$xtail&#39;, [&#39;$y&#39;, &#39;$ytail&#39;] ] }
        ]}
    ],
    [
        { next_to : [&#39;$x&#39;, &#39;$y&#39;, &#39;$list&#39;] },
        { $and : [ 
            { $call : [ &#39;parseList&#39;, &#39;$list&#39;, [&#39;$head&#39;, &#39;$tail&#39;] ] },
            { next_to : [ &#39;$x&#39;, &#39;$y&#39;, &#39;$tail&#39; ] }
        ] }
    ]
];

var response = {};
var query1 = [ { next_to : [&#39;$x&#39;, &#39;$y&#39;, [ 1 , [ 2 , 3 ] , 4 ] ] } ];
var query2 = [ { next_to : [&#39;$x&#39;, 1 , [ 2, 1, 3, 1] ] } ];

/* we add another query to enumerate all neighbors */
var query3 = [ { next_to : [&#39;$x&#39;, &#39;$y&#39; , [ 2, 1, 3, 1] ] } ];



var jsl = new JSL({rules : ruleset.concat(rules), query: query1});
response.query1 = jsl.run();
jsl = new JSL({rules : ruleset.concat(rules), query: query2});
response.query2 = jsl.run();
jsl = new JSL({rules : ruleset.concat(rules), query: query3});
response.query3 = jsl.run();

/*
 *Responses to query1 show the rules working at the topmost level only; they only find neighbors at the
 *top level of the list.
 */
module.exports = response;


/*
response  

{
    &quot;query1&quot;: [
        [
            {
                &quot;next_to&quot;: [
                    1,
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        [
                            2,
                            3
                        ],
                        4
                    ]
                ]
            }
        ],
        [
            {
                &quot;next_to&quot;: [
                    [
                        2,
                        3
                    ],
                    4,
                    [
                        1,
                        [
                            2,
                            3
                        ],
                        4
                    ]
                ]
            }
        ]
    ],
    &quot;query2&quot;: [
        [
            {
                &quot;next_to&quot;: [
                    2,
                    1,
                    [
                        2,
                        1,
                        3,
                        1
                    ]
                ]
            }
        ],
        [
            {
                &quot;next_to&quot;: [
                    3,
                    1,
                    [
                        2,
                        1,
                        3,
                        1
                    ]
                ]
            }
        ]
    ],
    &quot;query3&quot;: [
        [
            {
                &quot;next_to&quot;: [
                    2,
                    1,
                    [
                        2,
                        1,
                        3,
                        1
                    ]
                ]
            }
        ],
        [
            {
                &quot;next_to&quot;: [
                    1,
                    3,
                    [
                        2,
                        1,
                        3,
                        1
                    ]
                ]
            }
        ],
        [
            {
                &quot;next_to&quot;: [
                    3,
                    1,
                    [
                        2,
                        1,
                        3,
                        1
                    ]
                ]
            }
        ]
    ]
}

*/
</code></pre><p><span id="exercise-462"></p>
<h2 id="exercise-4-62">Exercise 4.62</h2>
<p></span></p>
<pre><code>/*ui
Exertcise 4.62.  Define rules to implement the last-pair operation of exercise 2.17, which returns a list containing the last element of a nonempty list. Check your rules on queries such as (last-pair (3) ?x), (last-pair (1 2 3) ?x), and (last-pair (2 ?x) (3)). Do your rules work correctly on queries such as (last-pair ?x (3)) ?

        for reference,

        Exercise 2.17.  Define a procedure last-pair that returns the list that contains only the last element of a given (nonempty) list:

        (last-pair (list 23 72 149 34))
        (34)

*/

var JSL = require(&#39;../../..&#39;);

var ruleset = [];

/* 
    We take the liberty to translate the problem to last_element
    Since JS arrays are not lists of pairs

    We use the standard  callback &#39;parseList&#39; included with JSL, 
    it returns the head and tail of an array
    parseList is the building block of cons/cdr style recursive list processing in JSL    

    We also use the standard callback &#39;objEqual&#39; included with JSL,
    it tests two JS values (null, String, Object, Array) to check if they are equal
*/


var rules = [
    [
        { last_element : [&#39;$list&#39;, &#39;$x&#39;] },
        { $or : [
            { $and : [
                { $call: [ &#39;objEqual&#39;, &#39;$list&#39;, [], [] ] }, //&lt;-- must give an empty array at end to avoid confusing outObj interpretation
                {$bind : [ &#39;$x&#39;, [] ] }
            ]},
            { $and : [
                { $call : [ &#39;parseList&#39;, &#39;$list&#39;, [ &#39;$head&#39;, &#39;$tail&#39; ] ] },
                { $call : [ &#39;objEqual&#39;, &#39;$tail&#39;, [], [] ] }, //&lt;-- must give an empty array at end to avoid confusing outObj interpretation
                {$bind : [ &#39;$x&#39;, &#39;$head&#39; ] }
            ] },
            { $and : [ 
                { $call : [ &#39;parseList&#39;, &#39;$list&#39;, [ &#39;$head&#39;, &#39;$tail&#39; ] ] },
                { last_element : [ &#39;$tail&#39;, &#39;$x&#39; ] }
            ] }
        ]}
    ]
];

var response = {};
var query1 = [ { last_element : [[3], &#39;$x&#39;] } ];
var query2 = [ { last_element : [[1,2,3], &#39;$x&#39;] } ];
var query3 = [ { last_element : [&#39;$x&#39;, [3]] } ];

/*
    query1 and query2 work as expected, reporting the last element of the given list
    query3 fortunately fails due to the implementation of parseList which returns null if the given input list is not an array
    Since $x is an unbound variable when parseList is $called in query3, it simply returns null
    so we get an empty list in the response

    It is possible to imagine the correct result of query3 being an infinite set of all lists with 3 at the end 
    but we do not obtain that result in our implementation

*/
var jsl = new JSL({rules : ruleset.concat(rules), query: query1});
response.query1 = jsl.run();
jsl = new JSL({rules : ruleset.concat(rules), query: query2});
response.query2 = jsl.run();
jsl = new JSL({rules : ruleset.concat(rules), query: query3});
response.query3 = jsl.run();

module.exports = response;


/*
response  

{
    &quot;query1&quot;: [
        [
            {
                &quot;last_element&quot;: [
                    [
                        3
                    ],
                    3
                ]
            }
        ]
    ],
    &quot;query2&quot;: [
        [
            {
                &quot;last_element&quot;: [
                    [
                        1,
                        2,
                        3
                    ],
                    3
                ]
            }
        ]
    ],
    &quot;query3&quot;: [
        [
            {
                &quot;last_element&quot;: [
                    [
                        3
                    ],
                    [
                        3
                    ]
                ]
            }
        ]
    ]
}

*/
</code></pre><p><span id="exercise-463"></p>
<h2 id="exercise-4-63">Exercise 4.63</h2>
<p></span></p>
<pre><code>/*
Exercise 4.63.  The following data base (see Genesis 4) traces the genealogy of the descendants of Ada back to Adam, by way of Cain:

(son Adam Cain)
(son Cain Enoch)
(son Enoch Irad)
(son Irad Mehujael)
(son Mehujael Methushael)
(son Methushael Lamech)
(wife Lamech Ada)
(son Ada Jabal)
(son Ada Jubal)

Formulate rules such as ``If S is the son of F, and F is the son of G, then S is the grandson of G&#39;&#39; and 
``If W is the wife of M, and S is the son of W, then S is the son of M&#39;&#39; (which was supposedly more true in biblical times 
than today) that will enable the query system to find the grandson of Cain; 
the sons of Lamech; 
the grandsons of Methushael. (See exercise 4.69 for some rules to deduce more complicated relationships.)

*/

var JSL = require(&#39;../../..&#39;);

var ruleset = [
    [{son : { parent : &#39;Adam&#39; , name : &#39;Cain&#39; } } ],
    [{son : { parent: &#39;Cain&#39; , name :  &#39;Enoch&#39; } } ],
    [{son : { parent : &#39;Enoch&#39; , name : &#39;Irad&#39; } } ],
    [{son : { parent : &#39;Irad&#39; , name : &#39;Mehujael&#39; } } ],
    [{son : { parent : &#39;Mehujael&#39; , name : &#39;Methushael&#39; } } ],
    [{son : { parent : &#39;Methushael&#39; , name : &#39;Lamech&#39; } } ],
    [{wife :{ husband : &#39;Lamech&#39; , name : &#39;Ada&#39; } } ],
    [{son : { parent : &#39;Ada&#39; , name : &#39;Jabal&#39; } } ],
    [{son : { parent : &#39;Ada&#39; , name : &#39;Jubal&#39; } } ]
]

var filterRules = [
    [
        { grandson : { grandfather : &#39;$grandfather&#39;, name : &#39;$grandson&#39;} },
        { son_of : { parent : &#39;$grandfather&#39;, name : &#39;$father&#39;} },
        { son_of : { parent : &#39;$father&#39;, name : &#39;$grandson&#39;} }
    ],
    [
        { son_of : { parent : &#39;$parent&#39;, name : &#39;$name&#39; } },
        { son : { parent : &#39;$x&#39;, name : &#39;$name&#39;} },
        { $or : [
            {$bind : [ &#39;$x&#39;, &#39;$parent&#39;] },
            { wife : { husband : &#39;$x&#39;, name : &#39;$parent&#39;} },
            { wife : { husband : &#39;$parent&#39;, name : &#39;$x&#39; } }
        ]}
    ]
];

var query;
var response = {}; 

query  = [ { grandson : { grandfather : &#39;Cain&#39;, name: &#39;$name&#39; } } ];
var jsl = new JSL({rules : ruleset.concat(filterRules), query: query});
response.grandson_of_Cain = jsl.run(); 

query = [ { son_of : { parent : &#39;Lamech&#39;, name : &#39;$name&#39;} } ];
jsl = new JSL({rules : ruleset.concat(filterRules), query: query});
response.sons_of_Lamech = jsl.run();

query = [ { grandson : { grandfather : &#39;Methushael&#39;, name: &#39;$name&#39; } } ];
jsl = new JSL({rules : ruleset.concat(filterRules), query: query});
response.grandsons_of_Methushael = jsl.run();

module.exports = response;


/*
response  

{
    &quot;grandson_of_Cain&quot;: [
        [
            {
                &quot;grandson&quot;: {
                    &quot;grandfather&quot;: &quot;Cain&quot;,
                    &quot;name&quot;: &quot;Irad&quot;
                }
            }
        ]
    ],
    &quot;sons_of_Lamech&quot;: [
        [
            {
                &quot;son_of&quot;: {
                    &quot;parent&quot;: &quot;Lamech&quot;,
                    &quot;name&quot;: &quot;Jabal&quot;
                }
            }
        ],
        [
            {
                &quot;son_of&quot;: {
                    &quot;parent&quot;: &quot;Lamech&quot;,
                    &quot;name&quot;: &quot;Jubal&quot;
                }
            }
        ]
    ],
    &quot;grandsons_of_Methushael&quot;: [
        [
            {
                &quot;grandson&quot;: {
                    &quot;grandfather&quot;: &quot;Methushael&quot;,
                    &quot;name&quot;: &quot;Jabal&quot;
                }
            }
        ],
        [
            {
                &quot;grandson&quot;: {
                    &quot;grandfather&quot;: &quot;Methushael&quot;,
                    &quot;name&quot;: &quot;Jubal&quot;
                }
            }
        ]
    ]
}

*/
</code></pre><p><span id="exercise-464"></p>
<h2 id="exercise-4-64">Exercise 4.64</h2>
<p></span></p>
<pre><code>/*
...
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (supervisor ?staff-person ?middle-manager)
               (outranked-by ?middle-manager ?boss))))
...
...

Exercise 4.64.  Louis Reasoner mistakenly deletes the outranked-by rule (section 4.4.1) from the data base. 
When he realizes this, he quickly reinstalls it. Unfortunately, he makes a slight change in the rule, and types it in as

(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (outranked-by ?middle-manager ?boss)
               (supervisor ?staff-person ?middle-manager))))

Just after Louis types this information into the system, DeWitt Aull comes by to find out who outranks Ben Bitdiddle. He issues the query

(outranked-by (Bitdiddle Ben) ?who)

After answering, the system goes into an infinite loop. Explain why.
*/

/*
    JSL $or does not work the same as the textbook implementation. It stops at the first successful object.
    Thus, it does not try to find all bosses for a given employee, it just stops at the first one.

    To enumerate all bosses of a given $name, we must include an additional object in the rule 
    which matches all employees in the database. Then our ruleset produces all bosses for a given $name

    Then we can reproduce the infinite recursion encountered by Louis by making the same rearrangement 

    The infinite recursion is caused by repeated invocation of outranked_by with an unbound variable, 
    giving the recursion no chance to terminate

    Thus one needs to be conscious of the order of evaluation of rules in JSL, just as with the textbook implementation
*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require(&#39;./db.js&#39;);


var filterRules = [
    [
        { outranked_by : { name : &#39;$name&#39;, boss : &#39;$boss&#39;} },
        { employee : { name : &#39;$boss&#39;, address : &#39;$address&#39;}}, //&lt;-- additional rule to enumerate all employees
        { $or : [
            { supervisor : { name : &#39;$name&#39;, manager : &#39;$boss&#39; } },
            { $and : [
                { supervisor : { name : &#39;$name&#39;, manager : &#39;$middleManager&#39;} },
                { outranked_by : { name : &#39;$middleManager&#39;, boss : &#39;$boss&#39; } },
            ]},
        ]}
    ]
];


/* this rearrangement produces an infinite loop */

/*
var badRules = [
    [
        { outranked_by : { name : &#39;$name&#39;, boss : &#39;$boss&#39;} },
        { employee : { name : &#39;$boss&#39;, address : &#39;$address&#39;}},
        { $or : [
            { supervisor : { name : &#39;$name&#39;, manager : &#39;$boss&#39; } },
            { $and : [
                { outranked_by : { name : &#39;$middleManager&#39;, boss : &#39;$boss&#39; } },
                { supervisor : { name : &#39;$name&#39;, manager : &#39;middleManager&#39;} }
            ]},
        ]}
    ]
];
*/

var query;
var response = {}; 

query  = [ { outranked_by : { name : &#39;Reasoner Louis&#39;, boss : &#39;$who&#39; } } ];
var jsl = new JSL({rules : ruleset.concat(filterRules), query: query});
response = jsl.run();

module.exports = response;


/*
response  

[
    [
        {
            &quot;outranked_by&quot;: {
                &quot;name&quot;: &quot;Reasoner Louis&quot;,
                &quot;boss&quot;: &quot;Bitdiddle Ben&quot;
            }
        }
    ],
    [
        {
            &quot;outranked_by&quot;: {
                &quot;name&quot;: &quot;Reasoner Louis&quot;,
                &quot;boss&quot;: &quot;Hacker Alyssa P&quot;
            }
        }
    ],
    [
        {
            &quot;outranked_by&quot;: {
                &quot;name&quot;: &quot;Reasoner Louis&quot;,
                &quot;boss&quot;: &quot;Warbucks Oliver&quot;
            }
        }
    ]
]

*/
</code></pre><p><span id="exercise-465"></p>
<h2 id="exercise-4-65">Exercise 4.65</h2>
<p></span></p>
<pre><code>/*
...
(rule (wheel ?person)
      (and (supervisor ?middle-manager ?person)
           (supervisor ?x ?middle-manager)))

...
...

Cy D. Fect, looking forward to the day when he will rise in the organization, 
gives a query to find all the wheels (using the wheel rule of section 4.4.1):

(wheel ?who)

To his surprise, the system responds

;;; Query results:
(wheel (Warbucks Oliver))
(wheel (Bitdiddle Ben))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))

Why is Oliver Warbucks listed four times?


*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require(&#39;./db.js&#39;);


var problemRules = [
    [
        { wheel :  &#39;$person&#39; },
        { $and : [ 
            { supervisor : { name : &#39;$middle-manager&#39;,  manager : &#39;$person&#39;} },
            { supervisor : { name : &#39;$x&#39;, manager : &#39;$middle-manager&#39; } } 
        ]}
    ]
];

var solutionRules = [
    [
        { wheel :  &#39;$person&#39; },
        { $and : [ 
            { supervisor : { name : &#39;$middle-manager&#39;,  manager : &#39;$person&#39;} },
            { supervisor : { name : &#39;$x&#39;, manager : &#39;$middle-manager&#39; } } 
        ]},
        { $call : [ &#39;notSeen&#39;, &#39;$person&#39;] }
    ]
];

var query;
var response = {}; 

query  = [ { wheel : &#39;$who&#39; } ];
var jsl = new JSL({rules : ruleset.concat(problemRules), query: query});
response.problem = jsl.run();

/*  to solve the duplication problem, we simply invent a callback which keeps (in its environment), a list of
    names already &quot;seen&quot;, and returns null for duplicates.
    A $call object added to the end of the rule effecively filters out duplicates
    The callback is given an array to work with during its construction

    The solution illustrates the ease of cooperation betweeh JSL rules and JS host environment
*/

function notSeen () {
    var list = []; // static variable
    return function(x) {
        var result = null;
        if (list.indexOf(x) &lt; 0) {
            result = true;
            list.push(x);
        }
        return result;
    }
}

var callbacks = {
    notSeen : notSeen()
}


jsl = new JSL({rules : ruleset.concat(solutionRules), query: query, callbacks : callbacks});
response.solution = jsl.run();

module.exports = response;


/*
response  

{
    &quot;problem&quot;: [
        [
            {
                &quot;wheel&quot;: &quot;Bitdiddle Ben&quot;
            }
        ],
        [
            {
                &quot;wheel&quot;: &quot;Warbucks Oliver&quot;
            }
        ],
        [
            {
                &quot;wheel&quot;: &quot;Warbucks Oliver&quot;
            }
        ],
        [
            {
                &quot;wheel&quot;: &quot;Warbucks Oliver&quot;
            }
        ],
        [
            {
                &quot;wheel&quot;: &quot;Warbucks Oliver&quot;
            }
        ]
    ],
    &quot;solution&quot;: [
        [
            {
                &quot;wheel&quot;: &quot;Bitdiddle Ben&quot;
            }
        ],
        [
            {
                &quot;wheel&quot;: &quot;Warbucks Oliver&quot;
            }
        ]
    ]
}

*/
</code></pre><p><span id="exercise-466"></p>
<h2 id="exercise-4-66">Exercise 4.66</h2>
<p></span></p>
<pre><code>/*
Exercise 4.66.  Ben has been generalizing the query system to provide statistics about the company. 
For example, to find the total salaries of all the computer programmers one will be able to say

(sum ?amount
     (and (job ?x (computer programmer))
          (salary ?x ?amount)))

In general, Ben&#39;s new system allows expressions of the form

(accumulation-function &lt;variable&gt;
                       &lt;query pattern&gt;)

where accumulation-function can be things like sum, average, or maximum. 
Ben reasons that it should be a cinch to implement this. He will simply feed the query pattern to qeval. 
This will produce a stream of frames. He will then pass this stream through a mapping function 
that extracts the value of the designated variable from each frame in the stream and feed the 
resulting stream of values to the accumulation function. Just as Ben completes the implementation and 
is about to try it out, Cy walks by, still puzzling over the wheel query result in exercise 4.65. 
When Cy shows Ben the system&#39;s response, Ben groans, ``Oh, no, my simple accumulation scheme won&#39;t work!&#39;&#39;

What has Ben just realized? Outline a method he can use to salvage the situation.

*/

/*
    Ben&#39;s approach won&#39;t work due to duplicates in possible outputs produced by rules which feed the accumulator
    We don&#39;t bother to reproduce the problem since it was done in exercise 4.65, along with a duplicate suppressor callback
    we simply use that callback here and introduce another callback to accumulate the sum
    this time we don&#39;t discard the output of the accumulator, but$bind it to a JSL variable, allowing us to output the sum
    Finally, we use the fact that response is simply an array of all the intermediate results returned by sum and pop its last element 
    to obtain the final response from the module

    This solution illustrates the application of JS and JSl working together on non trivial problems
*/

var JSL = require(&#39;../../..&#39;);

var ruleset = require(&#39;./db.js&#39;);



var solutionRules = [
    [
        { sum :  { title : &#39;$title&#39;, totalSalary : &#39;$total&#39; } },
        { $and : [ 
            { job : { name : &#39;$x&#39;,  title : &#39;$title&#39;} },
            { salary : { name : &#39;$x&#39;, amount : &#39;$amount&#39; } },
            { $call : [ &#39;notSeen&#39;, &#39;$x&#39;] },
            { $call : [ &#39;accum&#39;, &#39;$amount&#39;, [&#39;$total&#39;] ] } // use $total as out variable for callback to return into
        ]}
    ]
];



function notSeen () {
    var list = []; // static variable
    return function(x) {
        var result = null;
        if (list.indexOf(x) &lt; 0) {
            result = true;
            list.push(x);
        }
        return result;
    }
}

function accum () {
    var accumVar = 0; // static variable 
    return function(x) {
        return accumVar += x;
    }
}

var callbacks = {
    notSeen : notSeen(), 
    accum :  accum() 
}


var query = [{ sum : { title : &#39;computer programmer&#39;, totalSalary : &#39;$totalSalary&#39;}  }]
var jsl = new JSL({rules : ruleset.concat(solutionRules), query: query, callbacks : callbacks}) ;
var response = jsl.run();

module.exports = response.pop(); // just get the last result of accumulation


/*
response  

[
    {
        &quot;sum&quot;: {
            &quot;title&quot;: &quot;computer programmer&quot;,
            &quot;totalSalary&quot;: 75000
        }
    }
]

*/
</code></pre><p><span id="exercise-468"></p>
<h2 id="exercise-4-68">Exercise 4.68</h2>
<p></span></p>
<pre><code>/*ui
Exercise 4.68.  Define rules to implement the reverse operation of exercise 2.18, which returns a list containing the same elements as a given list in reverse order. (Hint: Use append-to-form.) Can your rules answer both (reverse (1 2 3) ?x) and (reverse ?x (1 2 3)) ?

        for reference,

        Exercise 2.18.  Define a procedure reverse that takes a list as argument and returns a list of the same elements in reverse order:

        (reverse (list 1 4 9 16 25))
        (25 16 9 4 1)
*/

var JSL = require(&#39;../../..&#39;);

var ruleset = [];

var rules = [
    [
        { reverse : [&#39;$list&#39;, &#39;$reverse&#39;] },
        { $or : [
            { $and : [
                { $call: [ &#39;objEqual&#39;, &#39;$list&#39;, [], [] ] },
                {$bind : [ &#39;$reverse&#39;, [] ] }
            ]},
            { $and : [
                { $call : [ &#39;parseList&#39;, &#39;$list&#39;, [ &#39;$head&#39;, &#39;$tail&#39; ] ] },
                { reverse : [ &#39;$tail&#39;, &#39;$tailreverse&#39;] },
                { $call : [ &#39;concat&#39;, &#39;$tailreverse&#39;, [&#39;$head&#39;], [&#39;$reverse&#39;] ] }
            ] },
            { $and : [
                { $call : [ &#39;parseList&#39;, &#39;$reverse&#39;, [ &#39;$head&#39;, &#39;$tail&#39; ] ] },
                { reverse : [ &#39;$tail&#39;, &#39;$tailreverse&#39;] },
                { $call : [ &#39;concat&#39;, &#39;$tailreverse&#39;, [&#39;$head&#39;], [&#39;$list&#39;] ] }
            ] }

        ]}
    ]
];

var response = {};
var query1 = [ { reverse : [[1,2,3], &#39;$x&#39;] } ];
var query2 = [ { reverse : [&#39;$x&#39;, [1,2,3] ] } ];


var jsl = new JSL({rules : ruleset.concat(rules), query: query1});
response.query1 = jsl.run();

jsl = new JSL({rules : ruleset.concat(rules), query: query2});
response.query2 = jsl.run();

/*
    Since our callback parseList fails on non array inputs, we can make either form of reverse query work 
    by writing 2 rules: one to satisfy reversing of first argument, and the second to satisfy reversing of second argument
    We take advantage of our knowledge that unbound variables will cause the callback to return null (fail)
*/


module.exports = response;


/*
response  

{
    &quot;query1&quot;: [
        [
            {
                &quot;reverse&quot;: [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        3,
                        2,
                        1
                    ]
                ]
            }
        ]
    ],
    &quot;query2&quot;: [
        [
            {
                &quot;reverse&quot;: [
                    [
                        3,
                        2,
                        1
                    ],
                    [
                        1,
                        2,
                        3
                    ]
                ]
            }
        ]
    ]
}

*/
</code></pre>
    </body>
</html>
